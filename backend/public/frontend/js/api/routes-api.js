// js/api/routes-api.js
// üåê API DE ROTAS - CONFIGURADA PARA BACKEND LOCAL

class RoutesAPI {
  constructor() {
    // üéØ CONFIGURA√á√ÉO PARA SEU BACKEND LOCAL
    this.baseURL = 'http://localhost:8080'; // ‚Üê SEU BACKEND LOCAL
    this.apiPrefix = '/api/routes';          // ‚Üê ENDPOINT DE ROTAS
    this.timeout = 10000;                    // 10 segundos timeout
    
    this.storage = {
      routes: 'dockflow_routes_cache',
      lastSync: 'dockflow_routes_last_sync'
    };
    
    this.isOnline = navigator.onLine;
    this.init();
  }

  // üöÄ Inicializa√ß√£o
  init() {
    console.log('üåê Inicializando API de Rotas (Backend Local)...');
    this.setupOfflineHandling();
    this.checkAPIAvailability();
  }

  // üì° Verificar disponibilidade da API
  async checkAPIAvailability() {
    try {
      console.log(`üì° Testando conex√£o com: ${this.baseURL}/health`);
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);
      
      const response = await fetch(`${this.baseURL}/health`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        const healthData = await response.json();
        console.log('‚úÖ API local dispon√≠vel:', healthData);
        this.isOnline = true;
        await this.syncLocalData();
      } else {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        console.warn('‚è∞ Timeout na conex√£o com API local, usando dados locais');
      } else {
        console.warn('‚ö†Ô∏è API local offline, usando armazenamento local:', error.message);
      }
      this.isOnline = false;
      this.initializeLocalStorage();
    }
  }

  // üíæ Inicializar armazenamento local
  initializeLocalStorage() {
    console.log('üíæ Inicializando armazenamento local...');
    
    // Rotas padr√£o se n√£o existirem
    if (!localStorage.getItem(this.storage.routes)) {
      const defaultRoutes = [
        {
          id: 1,
          code: 'SP-CENTRO',
          description: 'S√£o Paulo Centro',
          priority: 'high',
          active: true,
          created_at: new Date().toISOString(),
          region: 'Centro',
          city: 'S√£o Paulo',
          state: 'SP',
          loadings_count: 0
        },
        {
          id: 2, 
          code: 'SP-ZONA-SUL',
          description: 'S√£o Paulo Zona Sul',
          priority: 'normal',
          active: true,
          created_at: new Date().toISOString(),
          region: 'Zona Sul',
          city: 'S√£o Paulo',
          state: 'SP',
          loadings_count: 0
        },
        {
          id: 3,
          code: 'RJ-CENTRO',
          description: 'Rio de Janeiro Centro',
          priority: 'normal',
          active: true,
          created_at: new Date().toISOString(),
          region: 'Centro',
          city: 'Rio de Janeiro',
          state: 'RJ',
          loadings_count: 0
        }
      ];
      
      localStorage.setItem(this.storage.routes, JSON.stringify(defaultRoutes));
      console.log('‚úÖ Rotas padr√£o criadas no armazenamento local');
    }
  }

  // üîÑ Sincronizar dados locais com API
  async syncLocalData() {
    try {
      console.log('üîÑ Sincronizando dados locais com API...');
      
      // Buscar rotas da API
      const routes = await this.getAllRoutes();
      localStorage.setItem(this.storage.routes, JSON.stringify(routes));
      localStorage.setItem(this.storage.lastSync, new Date().toISOString());
      
      console.log('‚úÖ Dados sincronizados com sucesso');
    } catch (error) {
      console.error('‚ùå Erro na sincroniza√ß√£o:', error);
    }
  }

  // üìã CRUD DE ROTAS

  // ‚úÖ Buscar todas as rotas
  async getAllRoutes() {
    try {
      if (this.isOnline) {
        console.log('üì° Buscando rotas do backend local...');
        
        const response = await fetch(`${this.baseURL}${this.apiPrefix}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const result = await response.json();
          // Adaptar para a estrutura do seu backend
          const routes = result.success ? result.data : result;
          console.log(`‚úÖ ${routes.length} rotas recebidas do backend local`);
          localStorage.setItem(this.storage.routes, JSON.stringify(routes));
          return routes;
        } else {
          throw new Error(`Erro HTTP: ${response.status}`);
        }
      } else {
        // Usar dados locais
        const localRoutes = localStorage.getItem(this.storage.routes);
        const routes = localRoutes ? JSON.parse(localRoutes) : [];
        console.log(`üíæ ${routes.length} rotas carregadas do cache local`);
        return routes;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Usando dados locais devido ao erro:', error.message);
      const localRoutes = localStorage.getItem(this.storage.routes);
      return localRoutes ? JSON.parse(localRoutes) : [];
    }
  }

  // ‚ûï Criar nova rota
  async createRoute(routeData) {
    try {
      console.log('‚ûï Criando nova rota:', routeData);

      if (this.isOnline) {
        const response = await fetch(`${this.baseURL}${this.apiPrefix}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(routeData)
        });

        if (response.ok) {
          const result = await response.json();
          const newRoute = result.success ? result.data : result;
          console.log(`‚úÖ Rota criada no backend local: ${newRoute.code}`);
          this.updateLocalRoute(newRoute);
          return newRoute;
        } else {
          const errorData = await response.json();
          throw new Error(errorData.message || `Erro HTTP: ${response.status}`);
        }
      } else {
        // Salvar localmente
        const newRoute = {
          id: Date.now(),
          code: routeData.code.toUpperCase(),
          description: routeData.description,
          priority: routeData.priority || 'normal',
          active: true,
          created_at: new Date().toISOString(),
          region: this.extractRegion(routeData.description),
          city: this.extractCity(routeData.description),
          state: this.extractState(routeData.code),
          loadings_count: 0
        };
        
        this.updateLocalRoute(newRoute);
        console.log('üíæ Rota salva localmente (modo offline)');
        return newRoute;
      }
    } catch (error) {
      console.error('‚ùå Erro ao criar rota:', error);
      throw error;
    }
  }

  // üîÑ Atualizar rota
  async updateRoute(routeId, updateData) {
    try {
      if (this.isOnline) {
        const response = await fetch(`${this.baseURL}${this.apiPrefix}/${routeId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(updateData)
        });

        if (response.ok) {
          const result = await response.json();
          const updatedRoute = result.success ? result.data : result;
          console.log(`‚úÖ Rota atualizada no backend local: ${updatedRoute.code}`);
          this.updateLocalRoute(updatedRoute);
          return updatedRoute;
        } else {
          const errorData = await response.json();
          throw new Error(errorData.message || `Erro HTTP: ${response.status}`);
        }
      } else {
        // Atualizar localmente
        const routes = await this.getAllRoutes();
        const routeIndex = routes.findIndex(r => r.id == routeId);
        
        if (routeIndex !== -1) {
          routes[routeIndex] = { ...routes[routeIndex], ...updateData };
          localStorage.setItem(this.storage.routes, JSON.stringify(routes));
          console.log('üíæ Rota atualizada localmente (modo offline)');
          return routes[routeIndex];
        } else {
          throw new Error('Rota n√£o encontrada');
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao atualizar rota:', error);
      throw error;
    }
  }

  // ‚ùå Deletar rota
  async deleteRoute(routeId) {
    try {
      if (this.isOnline) {
        const response = await fetch(`${this.baseURL}${this.apiPrefix}/${routeId}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          console.log(`‚úÖ Rota deletada no backend local: ${routeId}`);
          this.removeLocalRoute(routeId);
          return true;
        } else {
          const errorData = await response.json();
          throw new Error(errorData.message || `Erro HTTP: ${response.status}`);
        }
      } else {
        // Remover localmente
        this.removeLocalRoute(routeId);
        console.log('üíæ Rota removida localmente (modo offline)');
        return true;
      }
    } catch (error) {
      console.error('‚ùå Erro ao deletar rota:', error);
      throw error;
    }
  }

  // üîç Buscar rota por ID
  async getRouteById(routeId) {
    try {
      if (this.isOnline) {
        const response = await fetch(`${this.baseURL}${this.apiPrefix}/${routeId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const result = await response.json();
          return result.success ? result.data : result;
        } else if (response.status === 404) {
          return null;
        } else {
          throw new Error(`Erro HTTP: ${response.status}`);
        }
      } else {
        const routes = await this.getAllRoutes();
        return routes.find(route => route.id == routeId) || null;
      }
    } catch (error) {
      console.error('‚ùå Erro ao buscar rota:', error);
      return null;
    }
  }

  // ü§ñ Encontrar melhor rota para XML
  async findBestRouteForXML(xmlData) {
    try {
      const city = xmlData.endereco?.cidade || 'S√£o Paulo';
      const state = xmlData.endereco?.uf || 'SP';
      
      console.log(`üîç Buscando melhor rota para: ${city}/${state}`);
      
      // Busca local (mesmo se API estiver online, para simplicidade)
      const routes = await this.getAllRoutes();
      
      // Buscar rotas da mesma cidade/estado
      let candidateRoutes = routes.filter(route => 
        route.active && (
          route.city === city || 
          route.state === state ||
          route.state === 'ALL'
        )
      );
      
      if (candidateRoutes.length === 0) {
        // Usar primeira rota dispon√≠vel ou criar autom√°tica
        candidateRoutes = routes.filter(route => route.active);
        if (candidateRoutes.length === 0) {
          console.warn('‚ö†Ô∏è Nenhuma rota ativa encontrada');
          return null;
        }
      }
      
      // Ordenar por prioridade e menor carga
      candidateRoutes.sort((a, b) => {
        const priorityOrder = { 'urgent': 3, 'high': 2, 'normal': 1 };
        const aPriority = priorityOrder[a.priority] || 1;
        const bPriority = priorityOrder[b.priority] || 1;
        
        if (aPriority !== bPriority) {
          return bPriority - aPriority;
        }
        
        return (a.loadings_count || 0) - (b.loadings_count || 0);
      });
      
      const bestRoute = candidateRoutes[0];
      console.log(`‚úÖ Melhor rota encontrada: ${bestRoute.code}`);
      return bestRoute;
      
    } catch (error) {
      console.error('‚ùå Erro ao encontrar melhor rota:', error);
      return null;
    }
  }

  // üöÄ Criar rota autom√°tica para XML
  async createAutomaticRoute(xmlData) {
    try {
      const city = xmlData.endereco?.cidade || 'S√£o Paulo';
      const state = xmlData.endereco?.uf || 'SP';
      const timestamp = Date.now();
      
      const autoRouteData = {
        code: `AUTO-${state}-${timestamp}`,
        description: `Rota Autom√°tica - ${city}/${state}`,
        priority: 'normal'
      };
      
      console.log(`ü§ñ Criando rota autom√°tica para ${city}/${state}`);
      const newRoute = await this.createRoute(autoRouteData);
      
      console.log(`‚úÖ Rota autom√°tica criada: ${newRoute.code}`);
      return newRoute;
      
    } catch (error) {
      console.error('‚ùå Erro ao criar rota autom√°tica:', error);
      return null;
    }
  }

  // üìà Incrementar contador de carregamentos da rota
  async incrementRouteLoadings(routeId) {
    try {
      // Incrementar localmente
      const routes = await this.getAllRoutes();
      const routeIndex = routes.findIndex(r => r.id == routeId);
      
      if (routeIndex !== -1) {
        routes[routeIndex].loadings_count = (routes[routeIndex].loadings_count || 0) + 1;
        localStorage.setItem(this.storage.routes, JSON.stringify(routes));
        console.log(`üìà Contador incrementado para rota: ${routeId}`);
      }
    } catch (error) {
      console.error('‚ùå Erro ao incrementar contador:', error);
    }
  }

  // üìä Estat√≠sticas das rotas
  async getRoutesStats() {
    try {
      const routes = await this.getAllRoutes();
      
      return {
        total: routes.length,
        active: routes.filter(r => r.active).length,
        by_priority: {
          urgent: routes.filter(r => r.priority === 'urgent').length,
          high: routes.filter(r => r.priority === 'high').length,
          normal: routes.filter(r => r.priority === 'normal').length
        },
        by_state: routes.reduce((acc, route) => {
          const state = route.state || 'Indefinido';
          acc[state] = (acc[state] || 0) + 1;
          return acc;
        }, {}),
        total_loadings: routes.reduce((sum, route) => sum + (route.loadings_count || 0), 0)
      };
    } catch (error) {
      console.error('‚ùå Erro ao obter estat√≠sticas:', error);
      return null;
    }
  }

  // üîß M√âTODOS AUXILIARES

  // üíæ Atualizar rota local
  updateLocalRoute(route) {
    try {
      const routes = JSON.parse(localStorage.getItem(this.storage.routes) || '[]');
      const existingIndex = routes.findIndex(r => r.id == route.id);
      
      if (existingIndex !== -1) {
        routes[existingIndex] = route;
      } else {
        routes.push(route);
      }
      
      localStorage.setItem(this.storage.routes, JSON.stringify(routes));
    } catch (error) {
      console.error('‚ùå Erro ao atualizar rota local:', error);
    }
  }

  // üóëÔ∏è Remover rota local
  removeLocalRoute(routeId) {
    try {
      const routes = JSON.parse(localStorage.getItem(this.storage.routes) || '[]');
      const filteredRoutes = routes.filter(r => r.id != routeId);
      localStorage.setItem(this.storage.routes, JSON.stringify(filteredRoutes));
    } catch (error) {
      console.error('‚ùå Erro ao remover rota local:', error);
    }
  }

  // üåé Extrair regi√£o da descri√ß√£o
  extractRegion(description) {
    const regionPatterns = [
      /centro/i,
      /zona sul/i,
      /zona norte/i,
      /zona leste/i,
      /zona oeste/i,
      /ABC/i
    ];
    
    for (const pattern of regionPatterns) {
      if (pattern.test(description)) {
        return description.match(pattern)[0];
      }
    }
    
    return 'Geral';
  }

  // üèôÔ∏è Extrair cidade da descri√ß√£o
  extractCity(description) {
    const cityPatterns = [
      /S√£o Paulo/i,
      /Rio de Janeiro/i,
      /Belo Horizonte/i,
      /Salvador/i,
      /Bras√≠lia/i,
      /Curitiba/i,
      /Porto Alegre/i
    ];
    
    for (const pattern of cityPatterns) {
      if (pattern.test(description)) {
        return description.match(pattern)[0];
      }
    }
    
    return 'N√£o especificada';
  }

  // üó∫Ô∏è Extrair estado do c√≥digo
  extractState(code) {
    const statePattern = /^([A-Z]{2})/;
    const match = code.match(statePattern);
    return match ? match[1] : 'SP';
  }

  // üì± Configurar handling offline
  setupOfflineHandling() {
    window.addEventListener('online', () => {
      console.log('üåê Conectado √† internet - tentando reconectar √† API...');
      this.isOnline = true;
      this.checkAPIAvailability();
    });

    window.addEventListener('offline', () => {
      console.log('üì± Modo offline ativado');
      this.isOnline = false;
    });
  }
}

// üåê Inst√¢ncia global da API
window.RoutesAPI = new RoutesAPI();

console.log('‚úÖ RoutesAPI inicializada para backend local');